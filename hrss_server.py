import pandas as pd
from ast import literal_eval  # To convert a string of dict into a real dict
from flask import Flask, request, jsonify
from datetime import datetime
import logging
from cerberus import Validator
import requests

app = Flask(__name__)
# Initialize the global databases with corresponding columns but no data yet,
# so all of their len() will be 0. They're ready to store data. Done this in
# case some functions below need this info
physician_db = pd.DataFrame(
    columns=['attending_username', 'attending_email', 'attending_phone'])
patient_db = pd.DataFrame(
    columns=['patient_id', 'attending_username', 'patient_age',
             'heart_rate_history'])
admin_db = pd.DataFrame(columns=['admin_username', 'admin_password'])


# **************************Junqi Lu starts**************************
def init_database():
    """Initialize the 3 dummy databases so teammates can work individually.
    It won't be run in the final code

    This function reads the corresponding csv files to initialize the 3
    dummy databases for each of the team members to work individually.
    physician_db and admin_db are generated by a simple read in csv
    files from pd package. patient_db, however, requires some data type
    conversions so the data type in each cell is as expected rather than a
    string of the corresponding data type

    Returns:
        0 (int): this is the value to indicate that the function
        successfully finished running
    """
    # This will be commented out eventually. This function doesn't need a
    # unit test but need docstring

    global physician_db
    global patient_db
    global admin_db

    physician_db = pd.read_csv('dummy_data/physicians_data.csv')

    patient_db = pd.read_csv('dummy_data/patients_clean_data.csv')
    patient_db = patient_db.astype(
        {'patient_id': int,
         'attending_username': str,
         'patient_age': int}).astype(object)  # Convert the data types in
    # these 3 columns accordingly
    patient_db['heart_rate_history'] = patient_db['heart_rate_history'].apply(
        literal_eval)  # Convert that column's values into dict

    admin_db = pd.read_csv('dummy_data/admin_data.csv')

    return 0


@app.route('/api/new_patient', methods=['POST'])
def post_new_patient_handler():
    """Receive data from route request, add new patient data into the
    patient database. It also sends back messages to requestor, makes a log,
    and also return a status code

     This function is the handler of the route '/api/new_patient'. It first
     receives input data from the request. Then with supporting functions,
     it validates whether the input data is valid in data types and formats
     and if so, adds the patient input data into the patient database.
     Finally, with supporting functions, it output an output message string
     and a status code back to the requester.

    Returns:
        out_msg (str): a message tell the requestor whether the patient data
        was successfully added into the patient_db or the request has some
        issues that need to be addressed and request again

        status (int): 200 if the patient data was successfully added into
        patient_db; 400 if the input patient data has some issues that need
        to be fixed and request again
    """
    # You do not have to test the Flask handler functions directly

    # Receive data from the route request
    in_data = request.get_json()

    # Validate inputs
    # type_judgement, type_msg_str = new_patient_type_validate(in_data)
    value_judgement, value_msg_list = new_patient_value_validate(in_data)
    # Commented out new_patient_type_validate(in_data) because
    # new_patient_value_validate(in_data) already has that function

    # Complete tasks
    out_msg, status = post_new_patient_worker(value_msg_list,
                                              value_judgement, in_data)
    # Based on value_judgement, it decides whether to add the in_data to the
    # database and also what message it should send out

    return out_msg, status


def post_new_patient_worker(value_msg_list, value_judgement, in_data,
                            test_mode=False):
    """The real working function that add the in_data to the patient_db
    based on the value_judgement

    Based on the value_judgement, this function decides whether to add the
    in_data to patient_db and make a log to indicate the addition was
    successful, or it rejects the addition and add a message to the previous
    out_msg_list to indicate that the in_data has problems in data types or
    values and send the request again

    Args:
        value_msg_list (list of str): a list collecting all the problems from
        the previous checks, if there's any

        value_judgement (bool): whether the in_data has passed the previous
        checks and is ready to be added into the patient_db

        in_data (dict): the input patient data in the format of {
        "patient_id": <int or str of int>, "attending_username": <str as
        LastName.FirstInitial>,
            "patient_age": <int or str of int>}

        test_mode (bool): default to be False. True only when used for unit
        testing the function so the unit test function doesn't add
        additional rows to the global database. Only use the test_mode if
        you're sure that some previous steps has added in 1 row

    Returns:
        out_msg (str): concatenated all the str inside out_msg_list

        status (int): 200 if the patient data was successfully added into
        patient_db; 400 if the input patient data has some issues that need
        to be fixed and request again
    """
    global patient_db

    out_msg_list = value_msg_list  # Keep adding messages on value_msg_list

    if len(physician_db) == 0:  # This means physician_db has no data yet,
        # so the in_data['attending_username'] will always be impossible to
        # pass the test--the physician_db doesn't know this physician exists
        out_msg_list.append('The physician database is empty. You need to '
                            'have at least 1 physician available to start to '
                            'register for new patients.')
        status = 400
    else:  # This means physician_db has at least 1 physician that new
        # patient can be used for "attending_username"

        if value_judgement:  # If the data type and data value
            # follow the rules and make sense--patient_id is valid and
            # unique, attending_username is valid and exists in
            # physician_db, and patient_age is valid
            add_new_patient(in_data)  # Add the new patient data into the
            if test_mode is True:  # For testing the post_new_patient_worker()
                global patient_db
                patient_db.drop(patient_db.tail(1).index,
                                inplace=True)  # Drop the last
                # row, aka the newly added row so this test function doesn't
                # modify the patient_db when it's finished

            # global patient_db
            logging.info('Patient with id {} was successfully '
                         'added into the patient database.'
                         .format(in_data['patient_id']))
            # Return information to requestor
            out_msg_list.append('Patient with id {} was '
                                'successfully '
                                'added into the patient database.'
                                .format(in_data['patient_id']))
            status = 200
        else:
            out_msg_list.append("Fix and request "
                                "again.")
            status = 400

    # Response to requestor
    out_msg = '\n'.join(out_msg_list)  # Concatenate all the strings together
    # into 1 string to be sent back to the requestor

    return out_msg, status


def in_data_type_validate(in_data, scheme):
    """Check whether the data type of in_data follows the requirements
    defined by scheme

    This function, by using the cerberus package, ensures that in_data is a
    dict that has follows the data type and structure defined by scheme.
    If a field didn't follow the correct type, it adds the error msg into the
    type_msg_list and outputs it so later functions can keep adding msg on
    this list

    Args:
        in_data (dict): the input data. It has different data structure
        based on which parent function calls it
        scheme (dict of dicts): each sub dict defines the requirements,
        data types, and regex pattern requirements for that data field. For
        example, scheme = {
        "patient_id": {'required': True,
                       'type': ['integer', 'string'],
                       'regex': '^[0-9][0-9]*$'
                       }
        }

    Returns:
        judgement (bool): True if all the data type are correct and False
        if at least 1 data type is wrong

        type_msg_list (list of str): a list that collect all the error msg
        from judging the data types in every field
    """
    if type(in_data) != dict:  # Ensure that the in_data is in the type of
        # dictionary
        return False, ['The input data need to be a dictionary.']

    valid = Validator(scheme)
    valid.allow_unknown = True  # Allow in_data to have extra data fields.
    # Without this line, if in_data has unknown data field, the judgement
    # will be False and the server return 400

    judgement = valid.validate(in_data)  # If all the data types match with
    # scheme, judgement is True

    type_msg_list = []
    if judgement is False:
        # msg = "At least 1 data type is problematic."
        for field_name, error_msg in valid.errors.items():
            error = "Field \"{}\" {}.".format(field_name, error_msg[0])
            type_msg_list.append(error)
    return judgement, type_msg_list


def new_patient_type_validate(in_data):
    """Check whether the data type of in_data follows the requirements for
    new patient posting

    This function, by using the cerberus package, ensures that in_data is a
    dict that has "patient_id" as an int or a str of an int,
    "attending_username" as a str that follows the format of
    LastName.FirstInitial, and "patient_age" as an int or a str of an int.
    If a field didn't follow the correct, it adds the error msg into the
    type_msg_list and outputs it so later functions can keep adding msg on
    this list

    Args:
        in_data (dict): the input patient data in the format of {
        "patient_id": <int or str of int>, "attending_username": <str as
        LastName.FirstInitial>,
            "patient_age": <int or str of int>}

    Returns:
        judgement (bool): True if all the data type are correct and False
        if at least 1 data type is wrong

        type_msg_list (list of str): a list that collect all the error msg
        from judging the data types in every field
    """
    scheme = {
        "patient_id": {'required': True,  # 'required':True ensures this data
                       # field must be in the input data
                       'type': ['integer', 'string'],
                       'regex': '^[0-9][0-9]*$',  # Can have leading 0
                       # If type is string, regex matches a string of number
                       # starting with any digit but zero
                       },
        "attending_username": {'required': True,
                               'type': 'string',
                               'regex': '^[A-Z][a-z]*.[A-Z]'
                               # regex matches a string in the format
                               # "LastName.FirstInitial" such as "Smith.J"
                               },
        "patient_age": {'required': True,
                        'type': ['integer', 'string'],
                        'regex': '^[0-9][0-9]*$',
                        # If type is string, regex matches a string of
                        # number starting with any digit but zero
                        'min': 1  # All patients will be one year old or older
                        }
    }

    judgement, type_msg_list = in_data_type_validate(in_data, scheme)

    return judgement, type_msg_list


def new_patient_value_validate(in_data):
    """Check whether the data values of in_data follows the requirements of
    new patient posting

    This function ensures that the values inside in_data make sense.
    In other words, whether the patient_id is already in use in patient_db
    and whether attending_username exists in the physician_db. It outputs a
    judgement on whether the in_data is okay to be added into the patient_db
    and also value_msg_list that collects all the previous messages so the
    later functions can keep adding in to this list

    Args:
        in_data (dict): the input patient data in the format of {
        "patient_id": <int or str of int>, "attending_username": <str as
        LastName.FirstInitial>,
            "patient_age": <int or str of int>}

    Returns:
        judgement (bool): True if all the data values are correct and False
        if at least 1 data value is wrong

        value_msg_list (list of str): a list that collect all the error msg
        from judging the data values in every field
    """
    global patient_db
    global physician_db

    type_judgement, type_msg_list = new_patient_type_validate(in_data)
    value_msg_list = type_msg_list  # Keep adding messages on type_msg_list

    if type_judgement is False:
        return False, value_msg_list
    else:  # All fields of the incoming patient data follows the correct data
        # types. The data first need to have correct data type and then is
        # checked for whether the value makes sense
        judgment = True
        try:
            if int(in_data['patient_id']) in \
                    patient_db['patient_id'].to_list():
                value_msg_list.append('This patient_id is already in use.')
                judgment = False
        except (ValueError, Exception):
            raise

        try:
            if in_data['attending_username'] not in \
                    list(physician_db['attending_username']):
                value_msg_list.append(
                    'No matching attending physician from physician '
                    'database.')
                judgment = False
        except (ValueError, Exception):
            raise
        # No need to check on the content of the patient_age, since patients
        # can have the same age. The condition that age is older than 1 has
        # been covered in the data type check

    return judgment, value_msg_list


def add_new_patient(in_data):
    """Add the new patient in_data into patient_db

    This function converts the in_data (now has data in correct data types
    and values) into a df and concatenate that df with the original
    patient_db. If the patient_id or patient_age is in the format of a str
    of an int, it also converts those into int to ensure the data types
    inside patient_db are correct

    Args:
        in_data (dict): the input patient data in the format of {
        "patient_id": <int or str of int>, "attending_username": <str as
        LastName.FirstInitial>,
            "patient_age": <int or str of int>}

    Returns:
        patient_db (df): the global pandas dataframe (df) that contains all
        the patient data
    """
    # The in_data will be in good formats and values before it reaches to
    # this function, so this function simply adds the in_data to the patient
    # db, with a small conversion if any integer is in the format of a string
    global patient_db

    # If necessary, convert in_data is a string of int, convert it into int
    # before adding to df
    in_data['patient_id'] = int(in_data['patient_id'])
    in_data['patient_age'] = int(in_data['patient_age'])

    in_data_df = pd.DataFrame(in_data, index=[0])  # Without index =[0],
    # you'll have ValueError: If using all scalar values, you must pass an
    # index
    patient_db = pd.concat([patient_db, in_data_df], ignore_index=True)
    # concat() is used to replace append() which will be deprecated. You
    # made a new df object here

    return patient_db  # Somehow I need to return patient_db; otherwise the
    # pd.concat() won't work and the patient_db remains unchanged in testing
    # function


@app.route('/api/heart_rate', methods=['POST'])
def post_heart_rate_handler():
    """Receive data from route request, add new heart rate measurement with
    a datetime stamp into the heart_rate_history of the patient database. It
    also sends back messages to requestor, makes a log and send out email
    when the heart rate is tachycardic, and also return a status code

    This function is the handler of the route '/api/heart_rate'. It first
     receives input data from the request. Then with supporting functions,
     it validates whether the input data is valid in data types and formats
     and if so, adds the heart_rate measurement into the patient database
     heart_rate_history column.
     Finally, with supporting functions, it output an output message string
     and a status code back to the requester.

    Returns:
        out_msg (str): a message tell the requestor whether the heart_rate
        data
        was successfully added into the patient_db or the request has some
        issues that need to be addressed and request again. It also tells
        whether the email was successfully sent when a heart_rate is
        tachycardic

        status (int): 200 if the heart_rate data was successfully added into
        patient_db; 400 if the input heart_rate data has some issues that need
        to be fixed and request again
    """
    # Receive data from the route request
    in_data = request.get_json()

    # Validate inputs
    # type_judgement, type_msg_str = new_patient_type_validate(in_data)
    value_judgement, value_msg_list = new_heart_rate_value_validate(in_data)
    # Commented out new_patient_type_validate(in_data) because
    # new_patient_value_validate(in_data) already has that function

    # Complete tasks
    out_msg, status = post_heart_rate_worker(value_msg_list,
                                             value_judgement, in_data)
    # Based on value_judgement, it decides whether to add the in_data to the
    # database and also what message it should send out

    return out_msg, status


def post_heart_rate_worker(value_msg_list, value_judgement, in_data,
                           test_mode=False):
    """The real working function that add the heart_rate to the patient_db
    heart_rate_history column based on the value_judgement

    Based on the value_judgement, this function decides whether to add the
    heart_rate to patient_db's heart_rate_history column. If a heart_rate is
    tachycardic, it sends out an email to the responsible physician and
    makes a log about the patient. It adds a message to the previous
    out_msg_list to indicate that the in_data has problems in data types or
    values and send the request again. Otherwise, it'll add a message saying
    the new heart_rate was added successfully to that patient's
    heart_rate_history

    Args:
        value_msg_list (list of str): a list collecting all the problems from
        the previous checks, if there's any

        value_judgement (bool): whether the in_data has passed the previous
        checks and is ready to be added into the patient_db

        in_data (dict): the input patient data in the format of {
        "patient_id": <patient_id>,
        "heart_rate": <heart_rate>
        } where both <patient_id> and <heart_rate> can be an int or a string
        of int

        test_mode (bool): default to be False. True only when used for unit
        testing the function so the unit test function doesn't add
        additional heart_rate to the global database. Only use the
        test_mode if you're sure that some previous steps has added in 1
        heart_rate measurement for testing

    Returns:
        out_msg (str): concatenated all the str inside out_msg_list

        status (int): 200 if the heart_rate data was successfully added into
        patient_db heart_rate_history dict; 400 if the input patient data has
        some issues that need to be fixed and request again
    """
    global patient_db

    out_msg_list = value_msg_list  # Keep adding messages on value_msg_list

    if len(patient_db) == 0:  # This means the patient_db is empty. No
        # patient means it's impossible to
        # add in new heart rate measurements for a patient
        out_msg_list.append('The patient database is empty. You need to '
                            'have at least 1 patient available to register '
                            'for new heart rate measurement.')
        status = 400
    else:  # This means patient_db has at least 1 patient that you can add new
        # heart rate measurement to
        if value_judgement:  # If the data type and data value
            # follow the rules and make sense
            patient_id = int(in_data['patient_id'])
            heart_rate_history_before_cell_value = \
                patient_db[patient_db['patient_id'] == patient_id][
                    'heart_rate_history'].values[0]

            if type(heart_rate_history_before_cell_value) == dict:  # This if
                # statement is necessary since a patient might exist but has
                # no heart_rate_history. In that case,
                # type(heart_rate_history_before_cell_value) is a float (nan)
                heart_rate_history_before = \
                    heart_rate_history_before_cell_value.copy()
                history_dict_exist = True  # history_dict_exist will be used
                # to determine different ways of incorporating the new heart
                # rate into the history
            else:  # Most likely the type will be a float for nan
                heart_rate_history_before = \
                    heart_rate_history_before_cell_value
                history_dict_exist = False

            add_new_heart_rate(in_data,
                               history_dict_exist)  # Add the new patient
            # data into the

            if test_mode is True:  # This allows the worker to delete the
                # additional heart rate from the history after unit testing

                row_index = \
                    patient_db.index[
                        patient_db['patient_id'] == patient_id].values[
                        0]  # Obtain the row_index to use df.loc[] to properly
                # change values

                # A less elegant way of restore the value in that cell
                patient_db.loc[row_index, 'heart_rate_history'] = [
                    heart_rate_history_before]  # Add in a list of dict

                patient_db['heart_rate_history'] = patient_db[
                    'heart_rate_history'].apply(lambda x: x[0] if type(
                        x) == list else x)  # For cells in column
                # "heart_rate_history", if the value of a cell is a list,
                # convert it into a dict; otherwise, keep it as it is

            age = \
                patient_db[patient_db['patient_id'] == in_data['patient_id']][
                    'patient_age'].values[0]

            if tachycardic_judge(age, in_data['heart_rate']):  # Tachycardia
                # is decided based on age and heart_rate
                email_msg, email_status = send_email(in_data)
                out_msg_list.append(email_msg)

            # Return information to requestor
            out_msg_list.append('Patient with id {} had a new heart rate '
                                'measurement successfully added into the '
                                'heart rate history.'
                                .format(in_data['patient_id']))
            status = 200
        else:
            out_msg_list.append("Fix and request "
                                "again.")
            status = 400

    # Response to requestor
    out_msg = '\n'.join(out_msg_list)  # Concatenate all the strings together
    # into 1 string to be sent back to the requestor

    return out_msg, status


def tachycardic_judge(age, heart_rate):
    """Judge whether a heart_rate is tachycardic based on the age

    This function judges whether a heart_rate is tachycardic with the given
    age of the patient. The relationship can be found here:
    https://www.wikiwand.com/en/Tachycardic#Diagnosis

    Args:
        age (int): patient age
        heart_rate (int): heart rate in bpm

    Returns:
        True or False (bool): the judgement made on whether heart_rate is
        tachycardic based on the given age
    """
    # All patients are older than 1-yr-old
    age_heart_rate_dict = {  # A dict for tachycardia diagnosis for patients
        # younger than 15-yr-old
        range(1, 3): 151,  # Inclusive range [1,2] for age in years. Belows
        # are the same
        range(3, 5): 137,  # Range [3, 4]
        range(5, 8): 133,  # Range [5,6,7]
        range(8, 12): 130,  # Range [8,9,10,11]
        range(12, 16): 119  # Range [12,13,14,15]
        # Older than 15-yr-old, the threshold is 100 bpm
    }

    if age > 15:  # Older than 15-yr-old, the threshold is 100 bpm
        if heart_rate > 100:
            return True
        else:
            return False
    else:
        for age_range, heart_rate_threshold in age_heart_rate_dict.items():
            if age in age_range:
                if heart_rate > heart_rate_threshold:
                    return True
                else:
                    return False


def send_email(in_data):
    """Send out an email through email server when a heart_rate is tachycardic

    This function makes a post request to the email server to simulate the
    process of sending an email with the info provided and return a msg and
    a status code to
    indicate whether the email was successfully sent

    Args:
        in_data (dict): the input patient data in the format of {
        "patient_id": <patient_id>,
        "heart_rate": <heart_rate>
        } where both <patient_id> and <heart_rate> can be an int or a string
        of int

    Returns:
        msg (str): a string similar to "E-mail sent to
        DrBanksJohn@BLH_hospital.com from
        tachycardic_heart_rate@BLH_hospital.com" as a verification that the
        email was successfully sent
        status (int): code to indicate whether the post request was
        successful (200) or failed (400)
    """
    # If you have the code to call the e-mail server in its own modular
    # function, you do not need to have a unit test for that function.
    patient_id = int(in_data['patient_id'])  # Already passed the data type
    # check
    heart_rate = int(in_data['heart_rate'])

    attending_physician_username = patient_db[patient_db[
                                                  'patient_id'] ==
                                              patient_id][
        'attending_username'].values[
        0]  # 1 patient_id has only 1 attending
    # physician so using [0] is fine
    attending_email = \
        physician_db[physician_db['attending_username']
                     == attending_physician_username][
            'attending_email'].values[
            0]  # 1
    # physician has only 1 email address so using [0] is fine

    logging.warning(
        'Patient with id {} has a tachycardic heart rate as '
        '{} bpm. An email has been sent to corresponding '
        'physician at {}'.format(patient_id,
                                 heart_rate,
                                 attending_email))

    # This e-mail should include the patient_id, the tachycardic heart rate,
    # and the date/time stamp of that heart rate
    out_data = {"from_email": 'tachycardic_heart_rate@BLH_hospital.com',
                "to_email": attending_email,
                "subject": 'Patient with id {} has a tachycardic heart '
                           'rate!'.format(patient_id),
                "content": 'Dear Dr. {},\nYour patient with id {} '
                           'has a '
                           'tachycardic heart rate '
                           'as {} bpm at {}.'.format(
                            attending_physician_username,
                            patient_id,
                            heart_rate,
                            current_time_str)}

    r = requests.post("http://vcm-7631.vm.duke.edu:5007/hrss/send_email",
                      json=out_data)
    status = r.status_code
    msg = r.text
    return msg, status


def new_heart_rate_type_validate(in_data):
    """Check whether the data type of in_data follows the requirements for
    new heart_rate posting

    This function, by using the cerberus package, ensures that in_data is a
    dict that has "patient_id" as an int or a str of an int,
    and "patient_age" as an int or a str of an int.
    If a field didn't follow the correct, it adds the error msg into the
    type_msg_list and outputs it so later functions can keep adding msg on
    this list

    Args:
        in_data (dict): the input patient data in the format of {
        "patient_id": <patient_id>,
        "heart_rate": <heart_rate>
        } where both <patient_id> and <heart_rate> can be an int or a string
        of int

    Returns:
        judgement (bool): True if all the data type are correct and False
        if at least 1 data type is wrong

        type_msg_list (list of str): a list that collect all the error msg
        from judging the data types in every field
    """
    scheme = {
        "patient_id": {'required': True,
                       'type': ['integer', 'string'],
                       'regex': '^[0-9][0-9]*$',
                       # If type is string, regex matches a string of number
                       # starting with any digit but zero
                       },
        "heart_rate": {'required': True,
                       'type': ['integer', 'string'],
                       'regex': '^[0-9][0-9]*$',
                       # If type is string, regex matches a string of
                       # number starting with any digit but zero. Also, the
                       # heart_rate can't be a decimal
                       }
    }

    judgement, type_msg_list = in_data_type_validate(in_data, scheme)

    return judgement, type_msg_list


def new_heart_rate_value_validate(in_data):
    """Check whether the data values of in_data follows the
    requirements of new heart rate posting

    This function ensures that the values inside in_data make sense.
    In other words, whether the patient_id is already existing in
    patient_db. It outputs a judgement on whether the in_data is okay to be
    added into the patient_db heart_rate_history dict and also
    value_msg_list that collects all the previous messages so the
    later functions can keep adding in to this list

    Args:
        in_data (dict): the input patient data in the format of {
        "patient_id": <patient_id>,
        "heart_rate": <heart_rate>
        } where both <patient_id> and <heart_rate> can be an int or a string
        of int

    Returns:
        judgement (bool): True if all the data values are correct and False
        if at least 1 data value is wrong

        value_msg_list (list of str): a list that collect all the error msg
        from judging the data values in every field
    """
    global patient_db

    type_judgement, type_msg_list = new_heart_rate_type_validate(in_data)
    value_msg_list = type_msg_list  # Keep adding messages on type_msg_list

    if type_judgement is False:
        return False, value_msg_list
    else:  # All fields of the incoming patient data follows the correct data
        # types. The data first need to have correct data type and then is
        # checked for whether the value makes sense
        judgment = True
        try:
            if int(in_data['patient_id']) not in \
                    patient_db['patient_id'].to_list():
                value_msg_list.append('This patient_id does not exist.')
                judgment = False
        except (ValueError, Exception):
            raise

        # No need to check on the content of the heart_rate, since patients
        # can have the same heart_rate.

    return judgment, value_msg_list


current_time_str = ''  # This global current_time_str will be updated by


# add_new_heart_rate() and shared with send_email()


def add_new_heart_rate(in_data, history_dict_exist):
    """Add the new heart rate in_data into patient_db heart_rate_history dict

    This function obtains the current datetime and convert that into a str,
    which will be used as the key to store the heart_rate. Based on the
    patient_id, it finds out the row_index of the corresponding patient's
    row in patient_db, and add the datetime_str:heart_rate pair into the
    dict stored in the field of heart_rate_history column. If the patient_id
    or heart_rate is in the format of a str of an int, it also converts
    those into int to ensure the data types inside patient_db are correct

    Args:
        in_data (dict): the input patient data in the format of {
        "patient_id": <patient_id>,
        "heart_rate": <heart_rate>
        } where both <patient_id> and <heart_rate> can be an int or a string
        of int

        history_dict_exist (bool): True if the patient already has a
        previous heart rate record; False if the patient has no previous
        history

    Returns:
        patient_db (df): the global pandas dataframe (df) that contains all
        the patient data
    """
    # Only in_data with the right data types and formats can reach this
    # function so this function simply adds in_data into the patient_db
    global patient_db
    global current_time_str

    # If necessary, convert in_data is a string of int, convert it into int
    # before adding to df
    in_data['patient_id'] = int(in_data['patient_id'])  # Already passed data
    # type check
    in_data['heart_rate'] = int(in_data['heart_rate'])

    current_time_str = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
    row_index = \
        patient_db.index[
            patient_db['patient_id'] == in_data['patient_id']].values[
            0]  # Can use this method because all patient_id are unique
    if history_dict_exist:
        patient_db.loc[row_index, 'heart_rate_history'][
            current_time_str] = in_data[
            'heart_rate']  # df.loc[] is the correct
        # method to change the value of a cell in a df
    else:  # New patient has no previous heart rate history, so this creates
        # a new dict with the first heart_rate record in that cell

        # A less elegant way of adding a dict in that cell since pd will
        # complain if directly adding in a dict into a cell
        patient_db.loc[row_index, 'heart_rate_history'] = [{
            current_time_str: in_data['heart_rate']}]  # Add in a list of dict

        patient_db['heart_rate_history'] = patient_db[
            'heart_rate_history'].apply(
            lambda x: x[0] if type(
                x) == list else x)  # For cells in column
        # "heart_rate_history", if the value of a cell is a list,
        # convert it into a dict; otherwise, keep it as it is

    return patient_db


def sort_heart_rate_history_dict(heart_rate_history_dict):
    """Sort a dictionary based on the key

    This function will sort the heart_rate_history_dict by the datetime key
    such that the latest heart rate record will be the last one of the dict

    Args:
        heart_rate_history_dict (dict): it stores all the
        datetime_str:heart_rate_int data pairs under the heart_rate_history
        column inside patient_db

    Returns:
        sorted_date_time_dict (dict): simply a sorted version of the
        heart_rate_history_dict with the most recent heart rate record as
        the last data pair in the dict
    """
    date_time_dict = {}
    for date_time_str, heart_rate in heart_rate_history_dict.items():
        date_time_dict[datetime.strptime(date_time_str, '%Y-%m-%d '
                                                        '%H:%M:%S')] = \
            heart_rate

    sorted_date_time_dict = dict(sorted(date_time_dict.items()))  # All the
    # keys in this dict will be datetime object

    sorted_date_time_dict_out = {}
    for date_time_obj, heart_rate in sorted_date_time_dict.items():
        sorted_date_time_dict_out[date_time_obj.strftime('%Y-%m-%d '
                                                         '%H:%M:%S')] = \
            heart_rate
    # Now all the keys in sorted_date_time_dict_out are str from the
    # corresponding datetime object following the format of "%Y-%m-%d %H:%M:%S"
    return sorted_date_time_dict_out


@app.route('/api/status/<patient_id>', methods=['GET'])
def get_patient_status_handler(patient_id):
    """Receive patient_id data from route request. If it's a good request,
    it returns a dict about the patient tachycardic status and the last
    heart rate measurement info; if it's a bad request, it sends back
    corresponding msg and ask the requestor to fix and request again.

    This function takes in a patient_id from the get request. Then,
    it'll judge on the data type and the value of the patient_id to ensure
    that patient_id is an int (or a str of an int) and it also exists in the
    patient_db. Based on the judgement, it will either return some message
    to indicate why a request is bad or a dict describing the patient
    tachycardic status and the last heart rate measurement info (the format
    is described below) or a msg saying the patient exists but has no
    heart_rate_history yet. Also, the corresponding the status code will be
    returned

    Args:
        patient_id (int or a str of int): the ID that identifies a patient
        in patient_db

    Returns:
        jsonify(out) (JSON str): it's either a JSON str of a dict that
        contains a patient's heart rate info or a message saying the
        request has some issues

        status (int): 200 if the patient's heart rate info is successfully
        returned; 400 if the
        input
        patient_id
        data has some issues (format wrong or doesn't have a heart rate
        history yet) that need
        to be fixed and request again
    """
    # Receive data from the route request
    # patient_id was passed in by parameter

    # Validate inputs
    value_judgement, value_msg_list = patient_id_value_validate(patient_id)

    # Complete tasks
    out, status = get_patient_status_worker(value_msg_list, value_judgement,
                                            patient_id)

    # Return the JSON str and status code back to requestor
    return jsonify(out), status


def get_patient_status_worker(value_msg_list, value_judgement, patient_id):
    """The real working function that get the heart rate info from the
    patient_db heart_rate_history column based on the value_judgement

    Based on the value_judgement, this function decides whether to obtain a
    patient's latest heart rate info from patient_db's heart_rate_history
    column.

    Args:
        value_msg_list (list of str): a list collecting all the problems from
        the previous checks, if there's any

        value_judgement (bool): whether the patient_id has passed the
        previous checks and is ready to be used to obtain the heart rate
        history from the patient_db

        patient_id (int or a str of int): the ID that identifies a patient
        in patient_db

    Returns:
        out_msg (str): concatenated all the str inside out_msg_list

        status (int): 200 if the latest heart rate info was successfully
        obtained from the patient_db heart_rate_history dict; 400 if the
        input patient_id has some type or value issues that need to be fixed
        and request again or the patient with the given patient_id doesn't
        have a heart_rate_history yet (These 2 conditions can bt
        distinguished by the sent-back msg from the requestor side)
    """
    global patient_db

    out_msg_list = value_msg_list  # Keep adding messages on value_msg_list

    if len(patient_db) == 0:  # This means the patient_db is empty. No
        # patient means it's impossible to
        # obtain the info of the last heart rate measurement of a patient
        out_msg_list.append('The patient database is empty. You need to '
                            'have at least 1 patient available to get the '
                            'info of the last heart rate measurement of a '
                            'patient.')
    else:  # This means patient_db has at least 1 patient from whom you may be
        # able to obtain the info of the last heart rate measurement of a
        # patient

        # Whether the patient has at least 1 heart rate measurement in the
        # heart_rate_history dict will be checked inside the next if block
        # by the line "if type(heart_rate_history) == dict: ". type(
        # heart_rate_history) won't be dict if that patient has no history

        if value_judgement:  # If the patient_id follows the correct data
            # type and exists in the patient_db
            patient_id = int(
                patient_id)  # It's safe to directly do the convert
            # here since both the data type and the content of patient_id has
            # been checked before this line
            heart_rate_history = patient_db[patient_db['patient_id'] ==
                                            patient_id][
                'heart_rate_history'].values[
                0]  # Using [0] is fine here since each
            # patient_id has only 1 dict that records all the heart rates or 1
            # nan for a new patient that has no heart_rate_history yet

            if type(heart_rate_history) == dict:  # This means the patient
                # has at least 1 heart_rate_history dict already

                # Codes below obtain latest_heart_rate
                sorted_heart_rate_history = sort_heart_rate_history_dict(
                    heart_rate_history)
                sorted_heart_rate_history_list = list(
                    sorted_heart_rate_history)
                latest_date_time = sorted_heart_rate_history_list[-1]
                latest_heart_rate = sorted_heart_rate_history[latest_date_time]

                age = patient_db[patient_db['patient_id'] == patient_id][
                    'patient_age'].values[0]

                if tachycardic_judge(age, latest_heart_rate):
                    tachycardic_status = 'tachycardic'
                else:
                    tachycardic_status = 'not tachycardic'

                out_dict = {
                    "heart_rate": latest_heart_rate,
                    "status": tachycardic_status,
                    "timestamp": latest_date_time
                }

                status = 200

                return out_dict, status
            else:  # This means the patient has no heart_rate_history dict.
                # Usually the type here is float, because the value is nan
                out_msg_list.append(
                    'This patient has no heart rate history yet.')

        else:
            out_msg_list.append('Fix and request again.')

    out_msg = '\n'.join(out_msg_list)
    status = 400
    return out_msg, status


def patient_id_type_validate(patient_id):
    """Check whether the data type of patient_id follows the requirements

    This function will only accept the patient_id in the type of int or a
    str of an int. If patient_id was rejected, it'll also add a msg to the
    list of all the msg that will be sent out to requestor

    Args:
        patient_id (int or a str of int): the ID that identifies a patient
        in patient_db

    Returns:
        judgement (bool): True if the data type is correct and False
        the data type is wrong

        type_msg_list (list of str): a list that collect the error msg
        from judging the data type of patient_id
    """
    type_msg_list = []
    judgement = bool()
    try:
        patient_id_ = int(patient_id)
        judgement = True
    except ValueError:
        judgement = False
        type_msg_list.append("The patient_id's data format is wrong.")
    finally:
        return judgement, type_msg_list


def patient_id_value_validate(patient_id):
    """Check whether the data values of patient_id exists in patient_db

    This function ensures that patient_id, now with the correct data type,
    exists in patient_db

    Args:
        patient_id (int or a str of int): the ID that identifies a patient
        in patient_db

    Returns:
        judgement (bool): True if the data value is correct (aka,
    patient_id exists in the patient_db) and False if the data value is wrong

        type_msg_list (list of str): a list that collect the error msg
        from judging the data type and data value of patient_id
    """
    global patient_db
    type_judgement, type_msg_list = patient_id_type_validate(patient_id)
    value_msg_list = type_msg_list  # Keep adding messages on type_msg_list

    if type_judgement is False:
        return False, value_msg_list
    else:
        judgment = True
        try:
            if int(patient_id) not in \
                    patient_db['patient_id'].to_list():
                value_msg_list.append(
                    'This patient_id does not exist.')
                judgment = False
        except (ValueError, Exception):
            raise

    return judgment, value_msg_list


@app.route('/api/heart_rate/<patient_id>', methods=['GET'])
def get_heart_rate_list_handler(patient_id):
    """Receive patient_id data from route request. If it's a good request,
    it returns a list of all int heart rate records from that patient; if
    it's a bad request, it sends back corresponding msg and ask the
    requestor to fix and request again.

    This function takes in a patient_id from the get request. Then,
    it'll judge on the data type and the value of the patient_id to ensure
    that patient_id is an int (or a str of an int) and it also exists in the
    patient_db. Based on the judgement, it will either return some message
    to indicate why a request is bad or a list of int  describing the patient
    heart rate records (the format
    is described below) or a msg saying the patient exists but has no
    heart_rate_history yet. Also, the corresponding the status code will be
    returned

    Args:
        patient_id (int or a str of int): the ID that identifies a patient
        in patient_db

    Returns:
        jsonify(out) (JSON str): it's either a JSON str of a list of int that
        contains a patient's heart rate records or a message saying the
        request has some issues

        status (int): 200 if the patient's heart rate records are successfully
        returned; 400 if the
        input
        patient_id
        data has some issues (format wrong or doesn't have a heart rate
        history yet) that need
        to be fixed and request again
    """
    # Receive data from the route request
    # patient_id was passed in by parameter

    # Validate inputs
    value_judgement, value_msg_list = patient_id_value_validate(patient_id)

    # Complete tasks
    out, status = get_heart_rate_list_worker(value_msg_list,
                                             value_judgement,
                                             patient_id)

    # Return the JSON str and status code back to requestor
    return jsonify(out), status


def get_heart_rate_list_worker(value_msg_list, value_judgement,
                               patient_id):
    """The real working function that get the heart rate records from the
    patient_db heart_rate_history column based on the value_judgement

    Based on the value_judgement, this function decides whether to obtain a
    patient's all heart rate records from patient_db's heart_rate_history
    column.

    Args:
        value_msg_list (list of str): a list collecting all the problems from
        the previous checks, if there's any

        value_judgement (bool): whether the patient_id has passed the
        previous checks and is ready to be used to obtain the heart rate
        history from the patient_db

        patient_id (int or a str of int): the ID that identifies a patient
        in patient_db

    Returns:
        out_msg (str): concatenated all the str inside out_msg_list

        status (int): 200 if all the heart rate records were successfully
        obtained from the patient_db heart_rate_history dict; 400 if the
        input patient_id has some type or value issues that need to be fixed
        and request again or the patient with the given patient_id doesn't
        have a heart_rate_history yet (These 2 conditions can bt
        distinguished by the sent-back msg from the requestor side)
    """
    global patient_db

    out_msg_list = value_msg_list  # Keep adding messages on value_msg_list

    if len(patient_db) == 0:  # This means patient_db is  empty. No
        # patient means it's impossible to
        # obtain a list of heart rate measurements of a patient
        out_msg_list.append('The patient database is empty. You need to '
                            'have at least 1 patient available to get all '
                            'the heart rates in a list of a patient.')
    else:  # This means patient_db has at least 1 patient from whom you may be
        # able to obtain a list of all the heart rate measurements

        # Whether the patient has at least 1 heart rate measurement in the
        # heart_rate_history dict will be checked inside the next if block
        # by the line "if type(heart_rate_history) == dict: ". type(
        # heart_rate_history) won't be dict if that patient has no history

        if value_judgement:  # If the patient_id follows the correct data
            # type and exists in the patient_db
            patient_id = int(
                patient_id)  # It's safe to directly do the convert
            # here since both the data type and the content of patient_id has
            # been checked before this line
            heart_rate_history = patient_db[patient_db['patient_id'] ==
                                            patient_id][
                'heart_rate_history'].values[
                0]  # Using [0] is fine here since each
            # patient_id has only 1 dict that records all the heart rates or 1
            # nan for a new patient that has no heart_rate_history yet

            if type(heart_rate_history) == dict:  # This means the patient
                # has a heart_rate_history dict already
                sorted_heart_rate_history = sort_heart_rate_history_dict(
                    heart_rate_history)

                out_list = list(
                    sorted_heart_rate_history.values())  # Convert the dict's
                # values into a list

                status = 200

                return out_list, status
            else:  # This means the patient has no heart_rate_history dict.
                # Usually the type here is float, because the value is nan
                out_msg_list.append(
                    'This patient has no heart rate history yet.')

        else:
            out_msg_list.append('Fix and request again.')

    out_msg = '\n'.join(out_msg_list)
    status = 400
    return out_msg, status


# **************************Junqi Lu ends**************************

# **************************Ramana Balla starts**************************
@app.route('/api/new_attending', methods=['POST'])
def post_new_attending():
    """Receive data from route request, add new attending data into the
    physician database. It also sends back messages to requestor, makes a log,
    and also return a status code

     This function is the handler of the route '/api/new_attending'. It first
     receives input data from the request. Then with supporting functions,
     it validates whether the input data is valid in data types and formats
     and if so, adds the patient input data into the patient database.
     Finally, with supporting functions, it output an output message string
     and a status code back to the requester.

    Returns:
        out_msg (str): a message tell the requestor whether the attending data
        was successfully added into the physician_db or the request has some
        issues that need to be addressed and request again

        status (int): 200 if the attending data was successfully added into
        patient_db; 400 if the input physician data has some issues that need
        to be fixed and request again
    """
    in_data = request.get_json()

    value_judgement, value_msg_list = new_attending_value_validate(in_data)

    out_msg, status = post_new_attending_worker(value_msg_list,
                                                value_judgement, in_data)

    return out_msg, status


def post_new_attending_worker(value_msg_list, value_judgement, in_data):
    """The real working function that add the in_data to the physician_db
    based on the value_judgement

    Based on the value_judgement, this function decides whether to add the
    in_data to physician_db and make a log to indicate the addition was
    successful, or it rejects the addition and add a message to the previous
    out_msg_list to indicate that the in_data has problems in data types or
    values and send the request again

    Args:
        value_msg_list (list of str): a list collecting all the problems from
        the previous checks, if there's any

        value_judgement (bool): whether the in_data has passed the previous
        checks and is ready to be added into the patient_db

        in_data (dict): the input attending data in the format of {
        "attending_username": <str as LastName.FirstInitial>,
        "attending_email": <str>,
        "attending_phone": <str>}

        test_mode (bool): default to be False. True only when used for unit
        testing the function so the unit test function doesn't add
        additional rows to the global database. Only use the test_mode if
        you're sure that some previous steps has added in 1 row

    Returns:
        out_msg (str): concatenated all the str inside out_msg_list

        status (int): 200 if the attending data was successfully added into
        physician_db; 400 if the input attending data has some issues that
        need to be fixed and request again
    """
    out_msg_list = value_msg_list

    if value_judgement:
        add_new_attending(in_data)
        logging.info('{} with email {} was successfully '
                     'added into the physician database'
                     .format(in_data['attending_username'],
                             in_data['attending_email']))
        out_msg_list.append('{} was successfully added into the '
                            'physician database'
                            .format(in_data['attending_username'],
                                    in_data['attending_email']))
        status = 200

    else:
        out_msg_list.append("Fix and request "
                            "again.")
        status = 400

    out_msg = '\n'.join(out_msg_list)

    return out_msg, status


def new_attending_type_validate(in_data):
    """Check whether the data type of in_data follows the requirements for
    new patient posting

    This function, by using the cerberus package, ensures that in_data is a
    dict that has "attending_phone" as a str,
    "attending_username" as a str that follows the format of
    LastName.FirstInitial, and "attending_email" as a str.
    If any field didn't follow the correct, it adds the error msg into the
    type_msg_list and outputs it so later functions can keep adding msg on
    this list

    Args:
        in_data (dict): the input attending data in the format of {
        "attending_phone": <str>, "attending_username": <str as
        LastName.FirstInitial>,
            "attending_email": <str>}

    Returns:
        judgement (bool): True if all the data type are correct and False
        if at least 1 data type is wrong

        type_msg_list (list of str): a list that collect all the error msg
        from judging the data types in every field
    """
    scheme = {
        "attending_username": {'required': True,
                               'type': 'string',
                               'regex': '^[A-Z][a-z]*.[A-Z]'
                               },
        "attending_email": {'required': True,
                            'type': 'string',
                            },
        "attending_phone": {'required': True,
                            'type': ['string'],
                            }
    }
    valid = Validator(scheme)
    judgement = valid.validate(in_data)

    type_msg_list = []
    if judgement is False:
        for field_name, error_msg in valid.errors.items():
            error = "Field \"{}\" {}.".format(field_name, error_msg[0])
            type_msg_list.append(error)

    return judgement, type_msg_list


def new_attending_value_validate(in_data):
    """Check whether the data values of in_data follows the requirements of
    new attending posting

    This function ensures that the values inside in_data make sense.
    In other words, whether attending_username exists in the physician_db.
    It outputs a judgement on whether the in_data is okay to be added into
    the physician_db and also value_msg_list that collects all the previous
    messages so the later functions can keep adding in to this list

    Args:
        in_data (dict): the input patient data in the format of {
        "attending_phone": <str>, "attending_username": <str as
        LastName.FirstInitial>,
            "attending_email": <str>}

    Returns:
        judgement (bool): True if all the data values are correct and False
        if at least 1 data value is wrong

        value_msg_list (list of str): a list that collect all the error msg
        from judging the data values in every field
    """
    global physician_db

    type_judgement, type_msg_list = new_attending_type_validate(in_data)
    value_msg_list = type_msg_list  # Keep adding messages on type_msg_list

    if type_judgement is False:
        return False, value_msg_list
    else:  # All fields of the incoming patient data follows the correct data
        # types. The data first need to have correct data type and then is
        # checked for whether the value makes sense
        judgment = True
        try:
            if in_data['attending_username'] in \
                    list(physician_db['attending_username']):
                value_msg_list.append(
                    'Physician already exists in physician '
                    'database.')
                judgment = False
        except (ValueError, Exception):
            raise

    return judgment, value_msg_list


def add_new_attending(in_data):
    """Add the new attending in_data into attending_db

    This function converts the in_data (now has data in correct data types
    and values) into a df and concatenate that df with the original
    physician_db.

    Args:
        in_data (dict): the input patient data in the format of {
        "attending_phone": <str>, "attending_username": <str as
        LastName.FirstInitial>,
            "attending_email": <str>}

    Returns:
        physician_db (df): the global pandas dataframe (df) that contains all
        the attending data
    """
    global physician_db

    in_data_df = pd.DataFrame(in_data, index=[0])
    physician_db = pd.concat([physician_db, in_data_df], ignore_index=True)

    return physician_db


@app.route("/api/heart_rate/average/<patient_id>", methods=["GET"])
def get_avg_heart_rate(patient_id):
    """Receives patient_id from route request, and returns the patient'safe
    average heart rate.

    This function is the handler of the route
    '/api/heart_rate/average/<patient_id>'. It first
    receives patient_id as input from request. Then with supporting functions,
    it validates whether the input data is valid in data types and formats
    and if so, it then checks if the patient_id exists on the patient_db. If
    it exists, it retrieves the heart rate history of the patient from the
    patient_db and calculates the average heart rate.

    Returns:
        jsonify(hr_avg) (json str): a json string with the average heart rate
    """

    value_judgement, value_msg_list = pat_id_value_validate(patient_id)

    hr_avg, out_msg, status = avg_hr_worker(value_msg_list,
                                            value_judgement, patient_id)

    if hr_avg == 0:
        return out_msg, status

    return jsonify(hr_avg)


def avg_hr_worker(value_msg_list, value_judgement, patient_id):
    """The real working function that calculates the average heart rate for
    requested patient, if information exists on the patient_db.

    Based on the value_judgement, this function decides whether to add the
    calculate the average heart rate. If judgement is true, it retrieves the
    heart rate dictionary from the patient_db for the corresponding patient_id
    and then calculates the average heart rate.

    Args:
        value_msg_list (list of str): a list collecting all the problems from
        the previous checks, if there's any

        value_judgement (bool): whether the in_data has passed the previous
        checks

        patient_id (<int> or <str>): input patient_id

    Returns:
        hr_avg (float): value of the average heart rate

        out_msg (str): concatenated all the str inside out_msg_list

        status (int): 200 if the validations were successful, and 400
        if not
    """
    out_msg_list = value_msg_list
    patient_id = int(patient_id)

    if value_judgement:
        hr_dict = hr_dict_retriever(patient_id)
        hr_avg = avg_hr(hr_dict)
        status = 200
    else:
        out_msg_list.append("Fix and request "
                            "again.")
        status = 400
        hr_avg = 0

    out_msg = '\n'.join(out_msg_list)

    return int(hr_avg), out_msg, status


def pat_id_type_validate(patient_id):
    """Check whether the data type of patient_id follows the requirements

    This function will only accept the patient_id in the type of int or a
    str of an int. If patient_id was rejected, it'll also add a msg to the
    list of all the msg that will be sent out to requestor

    Args:
        patient_id (int or a str of int): the ID that identifies a patient
        in patient_db

    Returns:
        judgement (bool): True if the data type is correct and False
        the data type is wrong

        type_msg_list (list of str): a list that collect the error msg
        from judging the data type of patient_id
    """
    pat_dict = {'patient_id': patient_id}
    scheme = {
        "patient_id": {'required': True,
                       'type': ['integer', 'string'],
                       'regex': '^[1-9][0-9]*$',
                       }
    }
    valid = Validator(scheme)
    judgement = valid.validate(pat_dict)

    type_msg_list = []

    if judgement is False:
        for field_name, error_msg in valid.errors.items():
            error = "Field \"{}\" {}.".format(field_name, error_msg[0])
            type_msg_list.append(error)

    return judgement, type_msg_list


def pat_id_value_validate(patient_id):
    """Check whether the data values of patient_id exists in patient_db

    This function ensures that patient_id, now with the correct data type,
    exists in patient_db

    Args:
        patient_id (int or a str of int): the ID that identifies a patient
        in patient_db

    Returns:
        judgement (bool): True if the data value is correct (aka,
    patient_id exists in the patient_db) and False if the data value is wrong

        type_msg_list (list of str): a list that collect the error msg
        from judging the data type and data value of patient_id
    """
    global patient_db

    type_judgement, type_msg_list = pat_id_type_validate(patient_id)
    value_msg_list = type_msg_list  # Keep adding messages on type_msg_list

    if type_judgement is False:
        return False, value_msg_list
    else:
        judgment = True
        try:
            if int(patient_id) not in \
                    patient_db['patient_id'].to_list():
                value_msg_list.append('This patient_id is not present.')
                judgment = False
        except (ValueError, Exception):
            raise

    return judgment, value_msg_list


def hr_dict_retriever(patient_id):
    """Retrieves the heart rate history dictionary from patient_db

    This function retrieves the heart rate history dictionary for the
    patient_id that is provided as input.

    Args:
        patient_id (int or a str of int): the ID that identifies a patient
        in patient_db

    Returns:
        hr_dict (dict): Dictionary containing heart rate history of the patient
        corresponding to the input patient_id
    """
    global patient_db

    patient_id = int(patient_id)
    pat = patient_db.loc[patient_db['patient_id'] == patient_id]
    ind = pat.index
    hr_dict = pat.loc[ind[0], 'heart_rate_history']

    return hr_dict


def avg_hr(hr_dict):
    """Calculates the average heart rate given the heart rate history
    dictionary

    Retrieves the values from the input heart rate history dictionary which
    contains the heart rates, and calculates the average.

    Args:
        hr_dict (dict): Dictionary containing heart rate history of the patient
        corresponding to the input patient_id

    Returns:
        avg (float): average heart rate from the dictionary
    """
    res = 0
    for val in hr_dict.values():
        res += val

    avg = res / len(hr_dict)

    return avg


@app.route("/api/heart_rate/interval_average", methods=["POST"])
def post_hr_interval_avg():
    """Receives data from route request, and calculates the average heart rate
    since the time given as input.

    This function is the handler of the route
    '/api/heart_rate/interval_average' It receives a dictionary
    containing the patient_id and the time since when the
    average heart rate is requested, which is input as a datetime object.

    Returns:
        jsonify(hr_avg1): json string containing the average heart rate value
    """
    in_data = request.get_json()

    judgement, msg_list = hr_pat_id_value_validate(in_data)

    hr_avg, out_msg, status = hr_interval_worker(judgement, msg_list, in_data)

    if status == 400:
        return out_msg, status
    elif hr_avg == 0:
        return out_msg, status
    hr_avg1 = int(hr_avg)
    return jsonify(hr_avg1)


def hr_interval_worker(judgement, msg_list, in_data):
    """The real working function that calculates the average heart rate since
    the time given as input.

    Based on the value_judgement, this function decides whether to calculate
    the average heart rate. If the judgement is True, it retrieves
    the heart rate history of the patient corresponding to the
    patient_id. It then compares the datetime stamps in the
    dictionary to retrieve the heart rates of days since the
    given time input. It then calculates the average heart rate.

    Args:
        value_msg_list (list of str): a list collecting all the problems from
        the previous checks, if there's any

        value_judgement (bool): whether the in_data has passed the previous
        checks and is ready to be added into the patient_db

        in_data (dict): the input patient data in the format of {
        "patient_id": <patient_id>,
        "heart_rate_average_since": <heart_rate_average_since>
        } where <patient_id> is an int or str and <heart_rate_avg_since>
        is a datetime object.

    Returns:
        out_msg (str): concatenated all the str inside out_msg_list

        status (int): 200 if heart rate dictionary was retrieved, and
        400 if not
    """
    out_msg_list = msg_list

    if judgement:
        patient_id = in_data['patient_id']
        hr_dict = hr_dict_retriever(patient_id)
        hr_list = hr_list_since_retriever(hr_dict, in_data)
        if len(hr_list) == 0:
            out_msg_list.append("No heart rates since given time")
            status = 200
            hr_avg = 0
        else:
            hr_avg = avg_hr_since(hr_list)
            status = 200
    else:
        out_msg_list.append("Fix and request "
                            "again.")
        status = 400

    out_msg = '\n'.join(out_msg_list)

    return hr_avg, out_msg, status


def avg_hr_since(hr_list):
    """Calculates the average heart rate given the heart rate since

    Takes the heart rates in the input list and calculates the average.

    Args:
        hr_dict (list): List containing the heart rates since the time input

    Returns:
        avg (float): average heart rate from the list
    """
    res = 0
    for val in hr_list:
        res += val

    avg = res / len(hr_list)

    return avg


def hr_list_since_retriever(dct, in_data):
    """Retrieves heart rate in a list that fit the requirement

    Receives the heart rate history dictionary and retrieves the heart rates
    as a list that occur after the datetime input.

    Args:
        dct (dict): Dictionary containing heart rate history of the patient

        in_data (dict): the input patient data in the format of {
        "patient_id": <patient_id>,
        "heart_rate_average_since": <heart_rate_average_since>
        } where <patient_id> is an int or str and <heart_rate_avg_since>
        is a datetime object.

    Returns:
        hr_list (list): heart rates list that occur after the input time
    """
    sorted_dict = sort_heart_rate_history_dict(dct)
    time_stamps = list(sorted_dict.keys())
    hrs = list(sorted_dict.values())

    date_string = in_data['heart_rate_average_since']
    date_format = '%Y-%m-%d %H:%M:%S'
    a = datetime.strptime(date_string, date_format)
    hr_list = []

    for (i, j) in zip(time_stamps, hrs):
        i_obj = datetime.strptime(i, date_format)
        c = a - i_obj
        if c.days < 0:
            hr_list.append(j)

    return hr_list


def hr_pat_id_value_validate(in_data):
    """Check whether the data values of patient_id exists in patient_db

    This function ensures that patient_id, now with the correct data type,
    exists in patient_db

    Args:
        patient_id (int or a str of int): the ID that identifies a patient
        in patient_db

    Returns:
        judgement (bool): True if the data value is correct (aka,
    patient_id exists in the patient_db) and False if the data value is wrong

        type_msg_list (list of str): a list that collect the error msg
        from judging the data type and data value of patient_id
    """
    global patient_db

    type_judgement, type_msg_list = hr_interval_type_validate(in_data)
    value_msg_list = type_msg_list  # Keep adding messages on type_msg_list

    if type_judgement is False:
        return False, value_msg_list
    else:
        judgment = True
        try:
            if int(in_data['patient_id']) not in \
                    patient_db['patient_id'].to_list():
                value_msg_list.append('This patient_id is not present.')
                judgment = False
        except (ValueError, Exception):
            raise

    return judgment, value_msg_list


def hr_interval_type_validate(in_data):
    """Check whether the data type of in_data follows the requirements

    This function, by using the cerberus package, ensures that in_data is a
    dict that has "patient_id" as an int or a str of an int,
    and "heart_rate_average_since" as datetime object.
    If a field didn't follow the correct, it adds the error msg into the
    type_msg_list and outputs it so later functions can keep adding msg on
    this list

    Args:
        in_data (dict): the input patient data in the format of {
        "patient_id": <patient_id>,
        "heart_rate_average_since": <heart_rate_avg_since>
        } where <patient_id> is an int and <heart_rate_avg_since> is a
        datetime object

    Returns:
        judgement (bool): True if all the data type are correct and False
        if at least 1 data type is wrong

        type_msg_list (list of str): a list that collect all the error msg
        from judging the data types in every field
    """

    def to_date(s):
        return datetime.strptime(s, '%Y-%m-%d %H:%M:%S')

    scheme = {
        "patient_id": {'required': True,
                       'type': ['integer', 'string'],
                       'regex': '^[0-9][0-9]*$',
                       },
        "heart_rate_average_since": {'required': True,
                                     'type': 'datetime',
                                     'coerce': to_date,
                                     }
    }
    valid = Validator(scheme)
    judgement = valid.validate(in_data)

    type_msg_list = []

    if judgement is False:
        for field_name, error_msg in valid.errors.items():
            error = "Field \"{}\" {}.".format(field_name, error_msg[0])
            type_msg_list.append(error)

    return judgement, type_msg_list


@app.route("/api/patients/<attending_username>", methods=["GET"])
def get_pat_list(attending_username):
    """Receive attending_username string from the route request and
    returns the information of patients under the attending.

    This function takes in a attending_username string and goes on to
    retrieve patients that have the input attending as their attending. It
    returns a list of dictionaries where each dictionary contains the
    patient_id, the time stamp of the last heart rate recording,
    the latest heart rate, and a string mentionining if the
    latest heart rate is tachycardic.

    Args:
        attending_username (str): string containing the attending username

    Returns:
        jsonify(pat_data) (JSON str): contanining the list of dictionaries
        containing information of the corresponding patients.
    """
    usr_name = attending_username
    judgement, msg_list = att_usr_value_validate(usr_name)

    pat_data, out_msg, status = pat_list_att_worker(msg_list,
                                                    judgement,
                                                    usr_name)

    if status == 400:
        return out_msg, status

    return jsonify(pat_data)


def pat_list_att_worker(msg_list, judgement, usr_name):
    """The real working function that returns the list of dictionaries
    containing patient info.

    Based on the value_judgement, proceeds to first find the indices of
    the patients matching the attending_username. It then puts each
    patient's id, last heart rate recording, the time stamp of the last
    recording, and whether this latest heart rate is tachycardic

    Args:
        value_msg_list (list of str): a list collecting all the problems from
        the previous checks, if there's any

        value_judgement (bool): whether the in_data has passed the previous
        checks

        usr_name (str): string containing the attending username

    Returns:
        pat_data(list of dict): list of dictionaries containing patients' info
        corresponding to the attending_username
        out_msg (str): concatenated all the str inside out_msg_list

        status (int): 200 if heart rate dictionary was retrieved, and 400
        if not
    """
    out_msg_list = msg_list
    pat_data = []

    if judgement:
        pat = patient_db.loc[patient_db['attending_username'] == usr_name]
        ind = pat.index
        if len(ind) == 0:
            pat_data = []
            status = 200
        else:
            for i in ind:
                dct = {}
                hr_dict = pat.loc[i, 'heart_rate_history']
                sorted_dict = sort_heart_rate_history_dict(hr_dict)
                hrs = list(sorted_dict.values())
                times = list(sorted_dict.keys())
                latest_time = times[-1]
                latest_hr = hrs[-1]
                age = pat.loc[i, 'patient_age']
                id = pat.loc[i, 'patient_id']
                a = tachycardic_judge(age, latest_hr)
                if a:
                    b = "tachycardic"
                else:
                    b = "not tachycardic"
                dct['patient_id'] = id
                dct['last_heart_rate'] = latest_hr
                dct['last_time'] = latest_time
                dct['status'] = b
                pat_data.append(dct)
                status = 200
    else:
        out_msg_list.append("Fix and request "
                            "again.")
        status = 400

    out_msg = '\n'.join(out_msg_list)

    return pat_data, out_msg, status


def att_usr_type_validate(usr_name):
    """Check whether the data type of attending_username follows the
    requirements

    This function will only accept the attending_username in the type of str.

    Args:
        usr_name (str): string containing attending_username

    Returns:
        judgement (bool): True if the data type is correct and False
        the data type is wrong

        type_msg_list (list of str): a list that collect the error msg
    """
    in_data = {'attending_username': usr_name}
    scheme = {
        "attending_username": {'required': True,
                               'type': 'string',
                               'regex': '^[A-Z][a-z]*.[A-Z]'
                               # regex matches a string in the format
                               # "LastName.FirstInitial" such as "Smith.J"
                               }
    }
    valid = Validator(scheme)
    judgement = valid.validate(in_data)  # If all the data types match with
    # scheme, judgement is True

    type_msg_list = []
    if judgement is False:
        # msg = "At least 1 data type is problematic."
        for field_name, error_msg in valid.errors.items():
            error = "Field \"{}\" {}.".format(field_name, error_msg[0])
            type_msg_list.append(error)

    return judgement, type_msg_list


def att_usr_value_validate(usr_name):
    """Check whether the data values of attending_username exists in patient_db

    This function ensures that attending_username, now with the correct
    data type, exists in patient_db

    Args:
        usr_name (str): string containing attending_username

    Returns:
        judgement (bool): True if the data value is correct (aka,
        patient_id exists in the patient_db) and False if the data value
        is wrong

        value_msg_list (list of str): a list that collect the error msg
    """
    global physician_db

    type_judgement, type_msg_list = att_usr_type_validate(usr_name)
    value_msg_list = type_msg_list  # Keep adding messages on type_msg_list

    if type_judgement is False:
        return False, value_msg_list
    else:  # All fields of the incoming patient data follows the correct data
        # types. The data first need to have correct data type and then is
        # checked for whether the value makes sense
        judgment = True
        try:
            if usr_name not in \
                    list(physician_db['attending_username']):
                value_msg_list.append(
                    'No matching attending physician from physician '
                    'database.')
                judgment = False
        except Exception:
            pass

    return judgment, value_msg_list


# **************************Ramana Balla ends**************************

# **************************Ziwei He starts**************************


@app.route('/api/new_administrator', methods=['POST'])
def admin_register_handler():
    '''Get administrator information

    Get the new administrator information and return the processing result to
    the user.

    Returns:
        message (string):
        Processing result of the input administrator data

        status (interger):
        Status code of the processing result. The code for Successful
        process is 200 and failed process is 400
    '''
    global admin_db
    in_data = request.get_json()
    message, status, admin_db = check_admin_register(in_data, admin_db)
    return message, status


#  Warning: Do not use admin=admin_db. The value of the default parameter is
#  determined at the function defining stage, so the value of admin will be
#  empty dataframe if writing in this way.
def check_admin_register(in_data, admin):
    '''Process the new administrator data

    This function checks the new administrator data. The wrong input data type,
    wrong key name in the input dictionary, duplicate username, short password
    (less than 8 characters), empty username, and unsafe password (password
    should have at least one letter and one digit) will be rejected.

    Args:
        in_data (dictionary):
        New administrator information. Ideally it should look like
        {"admin_username": <admin_username_as_str>,
         "admin_password:": <password_as_str>}

        admin (DataFrame):
        Dataframe with administrator information with the format of
        admin_username, admin_password
        <usr string>, <pwd string>
        ...

    Returns:
        message (string):
        Processing result of the input administrator data

        status (integer):
        Status code of the processing result. The code for Successful process
        is 200 and failed process is 400

        admin (dataframe):
        Dataframe with administrator information
    '''
    # Check data type and keys
    if type(in_data) is not dict:
        message = "Wrong input data type"
        status = 400
        return message, status, admin
    if len(in_data) != 2:
        message = "Wrong input dictionary"
        status = 400
        return message, status, admin
    try:
        usr = in_data['admin_username']
        pwd = in_data['admin_password']
    except KeyError:
        message = "Wrong key name"
        status = 400
        return message, status, admin
    if type(usr) is not str or type(pwd) is not str:
        message = "The username or password must be strings"
        status = 400
        return message, status, admin

    # Check if the username is already in use
    if admin[admin['admin_username'] == usr].size != 0:
        message = "Username is already in use"
        status = 400
    else:
        # Check username,. Accept the username as long as it has at least one
        # non-space character
        flag = False
        for i in usr:
            if i != ' ':
                flag = True
                break
        # Check password
        if flag:
            message = check_pwd(pwd)
            if message == 'pass':
                admin.loc[len(admin.index)] = [usr, pwd]
                message = "Successfully added new administrator information"
                status = 200
            else:
                status = 400
        else:
            message = "Username can not be empty"
            status = 400
    return message, status, admin


def check_pwd(pwd):
    '''Check the password format

    The function checks the password format. Only safe password with no less
    than 8 characters, at least one letter, and at least one digit will be
    accepted

    Args:
    pwd (string):
    Administrator password

    Returns:
    message (string):
    Analysis result

    '''
    if len(pwd) < 8:
        message = "Password should have at least 8 characters"
        return message
    letter, num = 0, 0
    for i in pwd:
        if i == ' ':
            message = "Password should contain at least one letter and one " \
                      + "number without spaces"
            return message
        else:
            if i.isalpha():
                letter += 1
            if i.isdigit():
                num += 1
    if letter < 1 or num < 1:
        message = "Password should contain at least one letter and one " + \
                  "number without spaces"
    else:
        message = 'pass'
    return message


@app.route('/api/admin/all_attendings', methods=['POST'])
def attending_handler():
    '''Handler function for attending physician

    This function takes the administrator information and return the
    information of attending physicians or error messages

    Returns:
    info (string or dictionary):
    Error messages or physician information

    status (integer)
    Status code. The value is 200 for correct administrator information,
    401 for incorrect administrator information, and 400 for other errors

    '''
    in_admin = request.get_json()
    info, status = attending_process(in_admin, physician_db, admin_db)
    return jsonify(info), status


def check_admin(in_admin, admin):
    '''Check the input administrator information

    This function checks the input administrator data against the database.
    First, it rejects input data with wrong data type, wrong keys, wrong value
    data type. Then, it checks the administrator database to see if there is
    any match. If there is a match, the function returns "pass" to indicate it
    finds a match.

    Args:
    in_admin (dictionary):
    Administrator information provided by the user. It should be formatted as
    below:
    {"admin_username": <admin_username_as_str>,
     "admin_password:": <password_as_str>}

    admin (DataFrame):
    Dataframe with administrator information with the format of
    admin_username, admin_password
    <usr string>, <pwd string>
    ...

    Returns:
    flag (string):
    Information of checking result

    '''

    if admin.size == 0:
        flag = "No registered administrator in the database, please " + \
               "register first"
        return flag
    try:
        usr = in_admin['admin_username']
        pwd = in_admin['admin_password']
    except KeyError:
        flag = "Wrong key name"
        return flag
    if type(usr) is not str or type(pwd) is not str:
        flag = "The username or password must be strings"
        return flag

    if admin[admin['admin_username'] == usr].size != 0:
        if admin[admin['admin_username'] == usr].iat[0, 1] == pwd:
            flag = 'pass'
        else:
            flag = 'Wrong password'
    else:
        flag = "Invalid username"
    return flag


def attending_process(in_admin, physician, adminP):
    '''Process the attending physician information

    Process the physician information if the administrator information is
    correct. Otherwise, it returns the error message.

    Args:
    in_admin (dictionary):
    in_admin (dictionary):
    Administrator information provided by the user. It should be formatted as
    below:
    {"admin_username": <admin_username_as_str>,
     "admin_password:": <password_as_str>}
    physician : DataFrame
        Dataframe with physicians' information
        attending_username, attending_email, attending_phone
        <physician str>, <email str>, <xxx-xxx-xxxx str>
        ...

    adminP : DataFrame
        Dataframe with administrator information with the format of
        admin_username, admin_password
        <usr string>, <pwd string>
        ...

    Returns:
    info (string or list):
        Error messages or a list of dictionary with physician information
        [
            {"attending_username": <str>,
             "attending_email": <str>,
             "attending_phone": <xxx-xxx-xxxx str>}
        ]

    status (integer):
        Status code. The value is 200 for correct administrator information,
        401 for incorrect administrator information, and 400 for other errors

    '''
    if type(in_admin) is not dict:
        info = "Wrong input data type"
        status = 400
        return info, status
    # Move the type check from check_admin to process functions to avoid errors
    if len(in_admin) != 2:
        info = "Wrong input dictionary"
        status = 400
        return info, status
    flag = check_admin(in_admin, adminP)
    if flag != 'pass':
        if flag in ["Wrong password", "Invalid username"]:
            status = 401
        else:
            status = 400
        info = flag
    else:
        if physician.size != 0:
            info = physician.to_dict('records')
            status = 200
        else:
            info = "No physician information found"
            status = 400
    return info, status


@app.route("/api/admin/all_patients", methods=["POST"])
def admin_patients_handler():
    '''Handler function for listing all patients

    This function takes the administrator information and return the
    information of patients or error messages

    Returns:
        info (string or dictionary):
        Error messages or patient information
        [
            {"patient_id": <int>,
             "attending_username": <str>,
             "patient_age": <int>}
        ]

        status (integer):
        Status code. The value is 200 for correct administrator information,
        401 for incorrect administrator information, and 400 for other errors

    '''
    in_admin = request.get_json()
    info, status = patient_process(in_admin, admin_db, patient_db)
    return jsonify(info), status


def patient_process(in_admin, adminP, patient):
    '''Process the patient information

    Process the patient information if the administrator information is
    correct. Otherwise, it returns the error message.

    Args:
    in_admin (dictionary):
    Administrator information provided by the user. It should be in the
    format of
    {"admin_username": <admin_username_as_str>,
     "admin_password:": <password_as_str>}

    patient (DataFrame):
    Patient information in the format of
    patient_id, attending_username, patient_age, heart_rate_history
    <int>, <attending_physician_str>, <int>, {"<datetime str>": <int>, ...}
    ...

    adminP (DataFrame):
    Dataframe with administrator information with the format of
    admin_username, admin_password
    <usr string>, <pwd string>
    ...

    Args:
    info (string or list):
    Error messages or a list of dictionary with patient information
    [
        {"patient_id": <int>,
         "attending_username": <str>,
         "patient_age": <int>}
    ]

    status (integer):
    Status code. The value is 200 for correct administrator information,
    401 for incorrect administrator information, and 400 for other errors
    '''
    if type(in_admin) is not dict:
        info = "Wrong input data type"
        status = 400
        return info, status
    # Move the type check from check_admin to process functions to avoid errors
    if len(in_admin) != 2:
        info = "Wrong input dictionary"
        status = 400
        return info, status
    flag = check_admin(in_admin, adminP)
    if flag != 'pass':
        if flag in ["Wrong password", "Invalid username"]:
            status = 401
        else:
            status = 400
        info = flag
    else:
        if patient.size != 0:
            info = patient.iloc[:, 0:3].to_dict('records')
            status = 200
        else:
            info = "No patient information found"
            status = 400
    return info, status


@app.route("/api/admin/all_tachycardia", methods=["POST"])
def admin_tachycardia_handler():
    '''Handler function for listing tachycardia

    This function takes the administrator information and return the
    information of patients or error messages

    Returns:
    info (string or dictionary):
    Error messages or patient and heart rate information
    [
        {"patient_id": <int>,
         "attending_username": <str>,
         "attending_email": <email str>,
         "tachycardia_datetime": <str>}
    ]

    status (integer):
    Status code. The value is 200 for correct administrator information,
    401 for incorrect administrator information, and 400 for other errors

    '''
    in_admin = request.get_json()
    info, status = tachycardia_process(in_admin, patient_db, physician_db,
                                       admin_db)
    return jsonify(info), status


#  Test could be done by importing globs or pass globs as a parameter
def tachycardia_process(in_admin, patient, physician, adminP):
    '''Detect and return the tachycardia timepoint of all the patients

    Detect the tachycardia timepoint if the administrator information is
    correct. Otherwise, it returns the error message.

    Args:
    in_admin (dictionary):
    Administrator information and the query time point provided by the
    user. It should be in the format of
    {"admin_username": <admin_username_as_str>,
     "admin_password:": <password_as_str>
     "since_time": <datetime string>}

    patient (DataFrame):
    Patient information in the format of
    patient_id, attending_username, patient_age, heart_rate_history
    <int>, <attending_physician_str>, <int>, {"<datetime str>": <int>, ...}
    ...

    physician (DataFrame):
    Physician information in the format of
    attending_username, attending_email, attending_phone
    <str>,             <email str>,      <xxx-xxx-xxxx str>
    ...

    adminP (DataFrame):
    Dataframe with administrator information with the format of
    admin_username, admin_password
    <usr string>, <pwd string>
    ...

    Returns:
    info (string or list):
    Error messages or a list of dictionary with patient and heart rate
    information
    [
        {"patient_id": <int>,
         "attending_username": <str>,
         "attending_email": <email str>,
         "tachycardia_datetime": <str>}
    ]

    status (integer):
    Status code. The value is 200 for correct administrator information,
    401 for incorrect administrator information, and 400 for other errors
    '''
    if type(in_admin) is not dict:
        info = "Wrong input data type"
        status = 400
        return info, status
    # Move the type check from check_admin to process functions to avoid errors
    if len(in_admin) != 3:
        info = "Wrong input dictionary"
        status = 400
        return info, status
    flag = check_admin(in_admin, adminP)
    if flag != 'pass':
        if flag in ["Wrong password", "Invalid username"]:
            status = 401
        else:
            status = 400
        info = flag
    else:
        try:
            time0 = in_admin["since_time"]
            time0 = datetime.fromisoformat(time0)
        except KeyError:
            info = "Please provide a time point"
            status = 400
            return info, status
        except (ValueError, TypeError):
            info = "The time point should be in the format of 'yyyy-mm-dd " + \
                   "hh:mm:ss', 'hh:mm:ss' is optional"
            status = 400
            return info, status

        if patient.size == 0:
            info = "No patient information found"
            status = 400
            return info, status
        if physician.size == 0:
            info = "No physician information found"
            status = 400
            return info, status
        info = []
        for _, row in patient.iterrows():
            if type(row["heart_rate_history"]) == dict:
                tmp_dict = row['heart_rate_history']
                tmp = [x for x in tmp_dict if datetime.fromisoformat(x) > time0
                       and is_tachycardia(row['patient_age'], tmp_dict[x])]
                if len(tmp) != 0:
                    patient_info = row.iloc[:2].to_dict()
                    email = physician[physician["attending_username"] ==
                                      patient_info["attending_username"]]. \
                        iat[0, 1]
                    patient_info["attending_email"] = email
                    patient_info["tachycardia_datetime"] = tmp
                    info.append(patient_info)
        status = 200
    return info, status


def is_tachycardia(age, bpm):
    '''Determine if the heart rate is tachycardia

    This function determines if a heart rate is tachycardia by both age and bpm

    Args:
    age (integer):
        Patient age
    bpm (integer):
        Beat per minute

    Returns:
    bool:
        True if the heart rate is tachycardia, False if the heart rate is not
        tachycardia

    Reference:
        https://en.wikipedia.org/wiki/Tachycardia
    '''
    age_cutoff = [2, 4, 7, 11, 15]
    bpm_cutoff = [151, 137, 133, 130, 119]
    for a, b in zip(age_cutoff, bpm_cutoff):
        if age <= a:
            if bpm > b:
                return True
            else:
                return False
    # Older than 15 years
    if bpm > 100:
        return True
    else:
        return False


# **************************Ziwei He ends**************************


def main():
    """Set up the log files to keep all the logs

    This function mainly set up the log file such that it takes in all the
    logs at and above the level of INFO. It also supress the debug logs from
    the package urllib3, which seems to related to the email sending
    simulation server

    Returns:
        0 (int): as an indicator to show that the function successfully run
    """
    logging.basicConfig(level=logging.INFO,
                        filename='logFile.log',
                        filemode='w')  # Comment this line out to see the logs
    # in the console
    logging.getLogger("urllib3").setLevel(logging.INFO)  # Supress debug
    # logging from urllib3 in test_hrss_server.py, which seems to be related
    # to the email server

    return 0


@app.route('/', methods=['GET'])
def server_on():
    return "Server is on"


#  Warning: Please restore the modification when you push your code!
if __name__ == '__main__':
    # init_database()
    # Will be commented out once the server code is done
    # print(physician_db) # Ensure init_database() worked

    # Lines below Ensure the data type were correctly converted
    # print(type(patient_db['patient_id'][0]) == int)
    # print(type(patient_db['heart_rate_history'][0]) == dict)

    main()
    app.run(host="0.0.0.0")  # Remote server
    # app.run()  # Local server
